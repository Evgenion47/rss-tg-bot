package app

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

//go:generate minimock -i homework-2/internal/app.Repository -o ./repository_mock.go -n RepositoryMock

import (
	"context"
	"homework-2/internal/models"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// RepositoryMock implements Repository
type RepositoryMock struct {
	t minimock.Tester

	funcCreateSource          func(ctx context.Context, data models.DCData) (err error)
	inspectFuncCreateSource   func(ctx context.Context, data models.DCData)
	afterCreateSourceCounter  uint64
	beforeCreateSourceCounter uint64
	CreateSourceMock          mRepositoryMockCreateSource

	funcCreateUser          func(ctx context.Context, user models.User) (err error)
	inspectFuncCreateUser   func(ctx context.Context, user models.User)
	afterCreateUserCounter  uint64
	beforeCreateUserCounter uint64
	CreateUserMock          mRepositoryMockCreateUser

	funcDeleteSource          func(ctx context.Context, data models.DCData) (err error)
	inspectFuncDeleteSource   func(ctx context.Context, data models.DCData)
	afterDeleteSourceCounter  uint64
	beforeDeleteSourceCounter uint64
	DeleteSourceMock          mRepositoryMockDeleteSource

	funcGetRSSBySource          func(ctx context.Context, data models.DCData) (r1 models.RSSNews, err error)
	inspectFuncGetRSSBySource   func(ctx context.Context, data models.DCData)
	afterGetRSSBySourceCounter  uint64
	beforeGetRSSBySourceCounter uint64
	GetRSSBySourceMock          mRepositoryMockGetRSSBySource

	funcGetSrcsByChat          func(ctx context.Context, user models.User) (s1 models.Sources, err error)
	inspectFuncGetSrcsByChat   func(ctx context.Context, user models.User)
	afterGetSrcsByChatCounter  uint64
	beforeGetSrcsByChatCounter uint64
	GetSrcsByChatMock          mRepositoryMockGetSrcsByChat
}

// NewRepositoryMock returns a mock for Repository
func NewRepositoryMock(t minimock.Tester) *RepositoryMock {
	m := &RepositoryMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CreateSourceMock = mRepositoryMockCreateSource{mock: m}
	m.CreateSourceMock.callArgs = []*RepositoryMockCreateSourceParams{}

	m.CreateUserMock = mRepositoryMockCreateUser{mock: m}
	m.CreateUserMock.callArgs = []*RepositoryMockCreateUserParams{}

	m.DeleteSourceMock = mRepositoryMockDeleteSource{mock: m}
	m.DeleteSourceMock.callArgs = []*RepositoryMockDeleteSourceParams{}

	m.GetRSSBySourceMock = mRepositoryMockGetRSSBySource{mock: m}
	m.GetRSSBySourceMock.callArgs = []*RepositoryMockGetRSSBySourceParams{}

	m.GetSrcsByChatMock = mRepositoryMockGetSrcsByChat{mock: m}
	m.GetSrcsByChatMock.callArgs = []*RepositoryMockGetSrcsByChatParams{}

	return m
}

type mRepositoryMockCreateSource struct {
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockCreateSourceExpectation
	expectations       []*RepositoryMockCreateSourceExpectation

	callArgs []*RepositoryMockCreateSourceParams
	mutex    sync.RWMutex
}

// RepositoryMockCreateSourceExpectation specifies expectation struct of the Repository.CreateSource
type RepositoryMockCreateSourceExpectation struct {
	mock    *RepositoryMock
	params  *RepositoryMockCreateSourceParams
	results *RepositoryMockCreateSourceResults
	Counter uint64
}

// RepositoryMockCreateSourceParams contains parameters of the Repository.CreateSource
type RepositoryMockCreateSourceParams struct {
	ctx  context.Context
	data models.DCData
}

// RepositoryMockCreateSourceResults contains results of the Repository.CreateSource
type RepositoryMockCreateSourceResults struct {
	err error
}

// Expect sets up expected params for Repository.CreateSource
func (mmCreateSource *mRepositoryMockCreateSource) Expect(ctx context.Context, data models.DCData) *mRepositoryMockCreateSource {
	if mmCreateSource.mock.funcCreateSource != nil {
		mmCreateSource.mock.t.Fatalf("RepositoryMock.CreateSource mock is already set by Set")
	}

	if mmCreateSource.defaultExpectation == nil {
		mmCreateSource.defaultExpectation = &RepositoryMockCreateSourceExpectation{}
	}

	mmCreateSource.defaultExpectation.params = &RepositoryMockCreateSourceParams{ctx, data}
	for _, e := range mmCreateSource.expectations {
		if minimock.Equal(e.params, mmCreateSource.defaultExpectation.params) {
			mmCreateSource.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateSource.defaultExpectation.params)
		}
	}

	return mmCreateSource
}

// Inspect accepts an inspector function that has same arguments as the Repository.CreateSource
func (mmCreateSource *mRepositoryMockCreateSource) Inspect(f func(ctx context.Context, data models.DCData)) *mRepositoryMockCreateSource {
	if mmCreateSource.mock.inspectFuncCreateSource != nil {
		mmCreateSource.mock.t.Fatalf("Inspect function is already set for RepositoryMock.CreateSource")
	}

	mmCreateSource.mock.inspectFuncCreateSource = f

	return mmCreateSource
}

// Return sets up results that will be returned by Repository.CreateSource
func (mmCreateSource *mRepositoryMockCreateSource) Return(err error) *RepositoryMock {
	if mmCreateSource.mock.funcCreateSource != nil {
		mmCreateSource.mock.t.Fatalf("RepositoryMock.CreateSource mock is already set by Set")
	}

	if mmCreateSource.defaultExpectation == nil {
		mmCreateSource.defaultExpectation = &RepositoryMockCreateSourceExpectation{mock: mmCreateSource.mock}
	}
	mmCreateSource.defaultExpectation.results = &RepositoryMockCreateSourceResults{err}
	return mmCreateSource.mock
}

//Set uses given function f to mock the Repository.CreateSource method
func (mmCreateSource *mRepositoryMockCreateSource) Set(f func(ctx context.Context, data models.DCData) (err error)) *RepositoryMock {
	if mmCreateSource.defaultExpectation != nil {
		mmCreateSource.mock.t.Fatalf("Default expectation is already set for the Repository.CreateSource method")
	}

	if len(mmCreateSource.expectations) > 0 {
		mmCreateSource.mock.t.Fatalf("Some expectations are already set for the Repository.CreateSource method")
	}

	mmCreateSource.mock.funcCreateSource = f
	return mmCreateSource.mock
}

// When sets expectation for the Repository.CreateSource which will trigger the result defined by the following
// Then helper
func (mmCreateSource *mRepositoryMockCreateSource) When(ctx context.Context, data models.DCData) *RepositoryMockCreateSourceExpectation {
	if mmCreateSource.mock.funcCreateSource != nil {
		mmCreateSource.mock.t.Fatalf("RepositoryMock.CreateSource mock is already set by Set")
	}

	expectation := &RepositoryMockCreateSourceExpectation{
		mock:   mmCreateSource.mock,
		params: &RepositoryMockCreateSourceParams{ctx, data},
	}
	mmCreateSource.expectations = append(mmCreateSource.expectations, expectation)
	return expectation
}

// Then sets up Repository.CreateSource return parameters for the expectation previously defined by the When method
func (e *RepositoryMockCreateSourceExpectation) Then(err error) *RepositoryMock {
	e.results = &RepositoryMockCreateSourceResults{err}
	return e.mock
}

// CreateSource implements Repository
func (mmCreateSource *RepositoryMock) CreateSource(ctx context.Context, data models.DCData) (err error) {
	mm_atomic.AddUint64(&mmCreateSource.beforeCreateSourceCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateSource.afterCreateSourceCounter, 1)

	if mmCreateSource.inspectFuncCreateSource != nil {
		mmCreateSource.inspectFuncCreateSource(ctx, data)
	}

	mm_params := &RepositoryMockCreateSourceParams{ctx, data}

	// Record call args
	mmCreateSource.CreateSourceMock.mutex.Lock()
	mmCreateSource.CreateSourceMock.callArgs = append(mmCreateSource.CreateSourceMock.callArgs, mm_params)
	mmCreateSource.CreateSourceMock.mutex.Unlock()

	for _, e := range mmCreateSource.CreateSourceMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmCreateSource.CreateSourceMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateSource.CreateSourceMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateSource.CreateSourceMock.defaultExpectation.params
		mm_got := RepositoryMockCreateSourceParams{ctx, data}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateSource.t.Errorf("RepositoryMock.CreateSource got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateSource.CreateSourceMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateSource.t.Fatal("No results are set for the RepositoryMock.CreateSource")
		}
		return (*mm_results).err
	}
	if mmCreateSource.funcCreateSource != nil {
		return mmCreateSource.funcCreateSource(ctx, data)
	}
	mmCreateSource.t.Fatalf("Unexpected call to RepositoryMock.CreateSource. %v %v", ctx, data)
	return
}

// CreateSourceAfterCounter returns a count of finished RepositoryMock.CreateSource invocations
func (mmCreateSource *RepositoryMock) CreateSourceAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateSource.afterCreateSourceCounter)
}

// CreateSourceBeforeCounter returns a count of RepositoryMock.CreateSource invocations
func (mmCreateSource *RepositoryMock) CreateSourceBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateSource.beforeCreateSourceCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.CreateSource.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateSource *mRepositoryMockCreateSource) Calls() []*RepositoryMockCreateSourceParams {
	mmCreateSource.mutex.RLock()

	argCopy := make([]*RepositoryMockCreateSourceParams, len(mmCreateSource.callArgs))
	copy(argCopy, mmCreateSource.callArgs)

	mmCreateSource.mutex.RUnlock()

	return argCopy
}

// MinimockCreateSourceDone returns true if the count of the CreateSource invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockCreateSourceDone() bool {
	for _, e := range m.CreateSourceMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateSourceMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateSourceCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateSource != nil && mm_atomic.LoadUint64(&m.afterCreateSourceCounter) < 1 {
		return false
	}
	return true
}

// MinimockCreateSourceInspect logs each unmet expectation
func (m *RepositoryMock) MinimockCreateSourceInspect() {
	for _, e := range m.CreateSourceMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.CreateSource with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateSourceMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateSourceCounter) < 1 {
		if m.CreateSourceMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryMock.CreateSource")
		} else {
			m.t.Errorf("Expected call to RepositoryMock.CreateSource with params: %#v", *m.CreateSourceMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateSource != nil && mm_atomic.LoadUint64(&m.afterCreateSourceCounter) < 1 {
		m.t.Error("Expected call to RepositoryMock.CreateSource")
	}
}

type mRepositoryMockCreateUser struct {
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockCreateUserExpectation
	expectations       []*RepositoryMockCreateUserExpectation

	callArgs []*RepositoryMockCreateUserParams
	mutex    sync.RWMutex
}

// RepositoryMockCreateUserExpectation specifies expectation struct of the Repository.CreateUser
type RepositoryMockCreateUserExpectation struct {
	mock    *RepositoryMock
	params  *RepositoryMockCreateUserParams
	results *RepositoryMockCreateUserResults
	Counter uint64
}

// RepositoryMockCreateUserParams contains parameters of the Repository.CreateUser
type RepositoryMockCreateUserParams struct {
	ctx  context.Context
	user models.User
}

// RepositoryMockCreateUserResults contains results of the Repository.CreateUser
type RepositoryMockCreateUserResults struct {
	err error
}

// Expect sets up expected params for Repository.CreateUser
func (mmCreateUser *mRepositoryMockCreateUser) Expect(ctx context.Context, user models.User) *mRepositoryMockCreateUser {
	if mmCreateUser.mock.funcCreateUser != nil {
		mmCreateUser.mock.t.Fatalf("RepositoryMock.CreateUser mock is already set by Set")
	}

	if mmCreateUser.defaultExpectation == nil {
		mmCreateUser.defaultExpectation = &RepositoryMockCreateUserExpectation{}
	}

	mmCreateUser.defaultExpectation.params = &RepositoryMockCreateUserParams{ctx, user}
	for _, e := range mmCreateUser.expectations {
		if minimock.Equal(e.params, mmCreateUser.defaultExpectation.params) {
			mmCreateUser.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateUser.defaultExpectation.params)
		}
	}

	return mmCreateUser
}

// Inspect accepts an inspector function that has same arguments as the Repository.CreateUser
func (mmCreateUser *mRepositoryMockCreateUser) Inspect(f func(ctx context.Context, user models.User)) *mRepositoryMockCreateUser {
	if mmCreateUser.mock.inspectFuncCreateUser != nil {
		mmCreateUser.mock.t.Fatalf("Inspect function is already set for RepositoryMock.CreateUser")
	}

	mmCreateUser.mock.inspectFuncCreateUser = f

	return mmCreateUser
}

// Return sets up results that will be returned by Repository.CreateUser
func (mmCreateUser *mRepositoryMockCreateUser) Return(err error) *RepositoryMock {
	if mmCreateUser.mock.funcCreateUser != nil {
		mmCreateUser.mock.t.Fatalf("RepositoryMock.CreateUser mock is already set by Set")
	}

	if mmCreateUser.defaultExpectation == nil {
		mmCreateUser.defaultExpectation = &RepositoryMockCreateUserExpectation{mock: mmCreateUser.mock}
	}
	mmCreateUser.defaultExpectation.results = &RepositoryMockCreateUserResults{err}
	return mmCreateUser.mock
}

//Set uses given function f to mock the Repository.CreateUser method
func (mmCreateUser *mRepositoryMockCreateUser) Set(f func(ctx context.Context, user models.User) (err error)) *RepositoryMock {
	if mmCreateUser.defaultExpectation != nil {
		mmCreateUser.mock.t.Fatalf("Default expectation is already set for the Repository.CreateUser method")
	}

	if len(mmCreateUser.expectations) > 0 {
		mmCreateUser.mock.t.Fatalf("Some expectations are already set for the Repository.CreateUser method")
	}

	mmCreateUser.mock.funcCreateUser = f
	return mmCreateUser.mock
}

// When sets expectation for the Repository.CreateUser which will trigger the result defined by the following
// Then helper
func (mmCreateUser *mRepositoryMockCreateUser) When(ctx context.Context, user models.User) *RepositoryMockCreateUserExpectation {
	if mmCreateUser.mock.funcCreateUser != nil {
		mmCreateUser.mock.t.Fatalf("RepositoryMock.CreateUser mock is already set by Set")
	}

	expectation := &RepositoryMockCreateUserExpectation{
		mock:   mmCreateUser.mock,
		params: &RepositoryMockCreateUserParams{ctx, user},
	}
	mmCreateUser.expectations = append(mmCreateUser.expectations, expectation)
	return expectation
}

// Then sets up Repository.CreateUser return parameters for the expectation previously defined by the When method
func (e *RepositoryMockCreateUserExpectation) Then(err error) *RepositoryMock {
	e.results = &RepositoryMockCreateUserResults{err}
	return e.mock
}

// CreateUser implements Repository
func (mmCreateUser *RepositoryMock) CreateUser(ctx context.Context, user models.User) (err error) {
	mm_atomic.AddUint64(&mmCreateUser.beforeCreateUserCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateUser.afterCreateUserCounter, 1)

	if mmCreateUser.inspectFuncCreateUser != nil {
		mmCreateUser.inspectFuncCreateUser(ctx, user)
	}

	mm_params := &RepositoryMockCreateUserParams{ctx, user}

	// Record call args
	mmCreateUser.CreateUserMock.mutex.Lock()
	mmCreateUser.CreateUserMock.callArgs = append(mmCreateUser.CreateUserMock.callArgs, mm_params)
	mmCreateUser.CreateUserMock.mutex.Unlock()

	for _, e := range mmCreateUser.CreateUserMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmCreateUser.CreateUserMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateUser.CreateUserMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateUser.CreateUserMock.defaultExpectation.params
		mm_got := RepositoryMockCreateUserParams{ctx, user}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateUser.t.Errorf("RepositoryMock.CreateUser got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateUser.CreateUserMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateUser.t.Fatal("No results are set for the RepositoryMock.CreateUser")
		}
		return (*mm_results).err
	}
	if mmCreateUser.funcCreateUser != nil {
		return mmCreateUser.funcCreateUser(ctx, user)
	}
	mmCreateUser.t.Fatalf("Unexpected call to RepositoryMock.CreateUser. %v %v", ctx, user)
	return
}

// CreateUserAfterCounter returns a count of finished RepositoryMock.CreateUser invocations
func (mmCreateUser *RepositoryMock) CreateUserAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateUser.afterCreateUserCounter)
}

// CreateUserBeforeCounter returns a count of RepositoryMock.CreateUser invocations
func (mmCreateUser *RepositoryMock) CreateUserBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateUser.beforeCreateUserCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.CreateUser.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateUser *mRepositoryMockCreateUser) Calls() []*RepositoryMockCreateUserParams {
	mmCreateUser.mutex.RLock()

	argCopy := make([]*RepositoryMockCreateUserParams, len(mmCreateUser.callArgs))
	copy(argCopy, mmCreateUser.callArgs)

	mmCreateUser.mutex.RUnlock()

	return argCopy
}

// MinimockCreateUserDone returns true if the count of the CreateUser invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockCreateUserDone() bool {
	for _, e := range m.CreateUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateUserMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateUserCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateUser != nil && mm_atomic.LoadUint64(&m.afterCreateUserCounter) < 1 {
		return false
	}
	return true
}

// MinimockCreateUserInspect logs each unmet expectation
func (m *RepositoryMock) MinimockCreateUserInspect() {
	for _, e := range m.CreateUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.CreateUser with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateUserMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateUserCounter) < 1 {
		if m.CreateUserMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryMock.CreateUser")
		} else {
			m.t.Errorf("Expected call to RepositoryMock.CreateUser with params: %#v", *m.CreateUserMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateUser != nil && mm_atomic.LoadUint64(&m.afterCreateUserCounter) < 1 {
		m.t.Error("Expected call to RepositoryMock.CreateUser")
	}
}

type mRepositoryMockDeleteSource struct {
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockDeleteSourceExpectation
	expectations       []*RepositoryMockDeleteSourceExpectation

	callArgs []*RepositoryMockDeleteSourceParams
	mutex    sync.RWMutex
}

// RepositoryMockDeleteSourceExpectation specifies expectation struct of the Repository.DeleteSource
type RepositoryMockDeleteSourceExpectation struct {
	mock    *RepositoryMock
	params  *RepositoryMockDeleteSourceParams
	results *RepositoryMockDeleteSourceResults
	Counter uint64
}

// RepositoryMockDeleteSourceParams contains parameters of the Repository.DeleteSource
type RepositoryMockDeleteSourceParams struct {
	ctx  context.Context
	data models.DCData
}

// RepositoryMockDeleteSourceResults contains results of the Repository.DeleteSource
type RepositoryMockDeleteSourceResults struct {
	err error
}

// Expect sets up expected params for Repository.DeleteSource
func (mmDeleteSource *mRepositoryMockDeleteSource) Expect(ctx context.Context, data models.DCData) *mRepositoryMockDeleteSource {
	if mmDeleteSource.mock.funcDeleteSource != nil {
		mmDeleteSource.mock.t.Fatalf("RepositoryMock.DeleteSource mock is already set by Set")
	}

	if mmDeleteSource.defaultExpectation == nil {
		mmDeleteSource.defaultExpectation = &RepositoryMockDeleteSourceExpectation{}
	}

	mmDeleteSource.defaultExpectation.params = &RepositoryMockDeleteSourceParams{ctx, data}
	for _, e := range mmDeleteSource.expectations {
		if minimock.Equal(e.params, mmDeleteSource.defaultExpectation.params) {
			mmDeleteSource.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteSource.defaultExpectation.params)
		}
	}

	return mmDeleteSource
}

// Inspect accepts an inspector function that has same arguments as the Repository.DeleteSource
func (mmDeleteSource *mRepositoryMockDeleteSource) Inspect(f func(ctx context.Context, data models.DCData)) *mRepositoryMockDeleteSource {
	if mmDeleteSource.mock.inspectFuncDeleteSource != nil {
		mmDeleteSource.mock.t.Fatalf("Inspect function is already set for RepositoryMock.DeleteSource")
	}

	mmDeleteSource.mock.inspectFuncDeleteSource = f

	return mmDeleteSource
}

// Return sets up results that will be returned by Repository.DeleteSource
func (mmDeleteSource *mRepositoryMockDeleteSource) Return(err error) *RepositoryMock {
	if mmDeleteSource.mock.funcDeleteSource != nil {
		mmDeleteSource.mock.t.Fatalf("RepositoryMock.DeleteSource mock is already set by Set")
	}

	if mmDeleteSource.defaultExpectation == nil {
		mmDeleteSource.defaultExpectation = &RepositoryMockDeleteSourceExpectation{mock: mmDeleteSource.mock}
	}
	mmDeleteSource.defaultExpectation.results = &RepositoryMockDeleteSourceResults{err}
	return mmDeleteSource.mock
}

//Set uses given function f to mock the Repository.DeleteSource method
func (mmDeleteSource *mRepositoryMockDeleteSource) Set(f func(ctx context.Context, data models.DCData) (err error)) *RepositoryMock {
	if mmDeleteSource.defaultExpectation != nil {
		mmDeleteSource.mock.t.Fatalf("Default expectation is already set for the Repository.DeleteSource method")
	}

	if len(mmDeleteSource.expectations) > 0 {
		mmDeleteSource.mock.t.Fatalf("Some expectations are already set for the Repository.DeleteSource method")
	}

	mmDeleteSource.mock.funcDeleteSource = f
	return mmDeleteSource.mock
}

// When sets expectation for the Repository.DeleteSource which will trigger the result defined by the following
// Then helper
func (mmDeleteSource *mRepositoryMockDeleteSource) When(ctx context.Context, data models.DCData) *RepositoryMockDeleteSourceExpectation {
	if mmDeleteSource.mock.funcDeleteSource != nil {
		mmDeleteSource.mock.t.Fatalf("RepositoryMock.DeleteSource mock is already set by Set")
	}

	expectation := &RepositoryMockDeleteSourceExpectation{
		mock:   mmDeleteSource.mock,
		params: &RepositoryMockDeleteSourceParams{ctx, data},
	}
	mmDeleteSource.expectations = append(mmDeleteSource.expectations, expectation)
	return expectation
}

// Then sets up Repository.DeleteSource return parameters for the expectation previously defined by the When method
func (e *RepositoryMockDeleteSourceExpectation) Then(err error) *RepositoryMock {
	e.results = &RepositoryMockDeleteSourceResults{err}
	return e.mock
}

// DeleteSource implements Repository
func (mmDeleteSource *RepositoryMock) DeleteSource(ctx context.Context, data models.DCData) (err error) {
	mm_atomic.AddUint64(&mmDeleteSource.beforeDeleteSourceCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteSource.afterDeleteSourceCounter, 1)

	if mmDeleteSource.inspectFuncDeleteSource != nil {
		mmDeleteSource.inspectFuncDeleteSource(ctx, data)
	}

	mm_params := &RepositoryMockDeleteSourceParams{ctx, data}

	// Record call args
	mmDeleteSource.DeleteSourceMock.mutex.Lock()
	mmDeleteSource.DeleteSourceMock.callArgs = append(mmDeleteSource.DeleteSourceMock.callArgs, mm_params)
	mmDeleteSource.DeleteSourceMock.mutex.Unlock()

	for _, e := range mmDeleteSource.DeleteSourceMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteSource.DeleteSourceMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteSource.DeleteSourceMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteSource.DeleteSourceMock.defaultExpectation.params
		mm_got := RepositoryMockDeleteSourceParams{ctx, data}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteSource.t.Errorf("RepositoryMock.DeleteSource got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteSource.DeleteSourceMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteSource.t.Fatal("No results are set for the RepositoryMock.DeleteSource")
		}
		return (*mm_results).err
	}
	if mmDeleteSource.funcDeleteSource != nil {
		return mmDeleteSource.funcDeleteSource(ctx, data)
	}
	mmDeleteSource.t.Fatalf("Unexpected call to RepositoryMock.DeleteSource. %v %v", ctx, data)
	return
}

// DeleteSourceAfterCounter returns a count of finished RepositoryMock.DeleteSource invocations
func (mmDeleteSource *RepositoryMock) DeleteSourceAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteSource.afterDeleteSourceCounter)
}

// DeleteSourceBeforeCounter returns a count of RepositoryMock.DeleteSource invocations
func (mmDeleteSource *RepositoryMock) DeleteSourceBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteSource.beforeDeleteSourceCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.DeleteSource.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteSource *mRepositoryMockDeleteSource) Calls() []*RepositoryMockDeleteSourceParams {
	mmDeleteSource.mutex.RLock()

	argCopy := make([]*RepositoryMockDeleteSourceParams, len(mmDeleteSource.callArgs))
	copy(argCopy, mmDeleteSource.callArgs)

	mmDeleteSource.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteSourceDone returns true if the count of the DeleteSource invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockDeleteSourceDone() bool {
	for _, e := range m.DeleteSourceMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteSourceMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteSourceCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteSource != nil && mm_atomic.LoadUint64(&m.afterDeleteSourceCounter) < 1 {
		return false
	}
	return true
}

// MinimockDeleteSourceInspect logs each unmet expectation
func (m *RepositoryMock) MinimockDeleteSourceInspect() {
	for _, e := range m.DeleteSourceMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.DeleteSource with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteSourceMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteSourceCounter) < 1 {
		if m.DeleteSourceMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryMock.DeleteSource")
		} else {
			m.t.Errorf("Expected call to RepositoryMock.DeleteSource with params: %#v", *m.DeleteSourceMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteSource != nil && mm_atomic.LoadUint64(&m.afterDeleteSourceCounter) < 1 {
		m.t.Error("Expected call to RepositoryMock.DeleteSource")
	}
}

type mRepositoryMockGetRSSBySource struct {
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockGetRSSBySourceExpectation
	expectations       []*RepositoryMockGetRSSBySourceExpectation

	callArgs []*RepositoryMockGetRSSBySourceParams
	mutex    sync.RWMutex
}

// RepositoryMockGetRSSBySourceExpectation specifies expectation struct of the Repository.GetRSSBySource
type RepositoryMockGetRSSBySourceExpectation struct {
	mock    *RepositoryMock
	params  *RepositoryMockGetRSSBySourceParams
	results *RepositoryMockGetRSSBySourceResults
	Counter uint64
}

// RepositoryMockGetRSSBySourceParams contains parameters of the Repository.GetRSSBySource
type RepositoryMockGetRSSBySourceParams struct {
	ctx  context.Context
	data models.DCData
}

// RepositoryMockGetRSSBySourceResults contains results of the Repository.GetRSSBySource
type RepositoryMockGetRSSBySourceResults struct {
	r1  models.RSSNews
	err error
}

// Expect sets up expected params for Repository.GetRSSBySource
func (mmGetRSSBySource *mRepositoryMockGetRSSBySource) Expect(ctx context.Context, data models.DCData) *mRepositoryMockGetRSSBySource {
	if mmGetRSSBySource.mock.funcGetRSSBySource != nil {
		mmGetRSSBySource.mock.t.Fatalf("RepositoryMock.GetRSSBySource mock is already set by Set")
	}

	if mmGetRSSBySource.defaultExpectation == nil {
		mmGetRSSBySource.defaultExpectation = &RepositoryMockGetRSSBySourceExpectation{}
	}

	mmGetRSSBySource.defaultExpectation.params = &RepositoryMockGetRSSBySourceParams{ctx, data}
	for _, e := range mmGetRSSBySource.expectations {
		if minimock.Equal(e.params, mmGetRSSBySource.defaultExpectation.params) {
			mmGetRSSBySource.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetRSSBySource.defaultExpectation.params)
		}
	}

	return mmGetRSSBySource
}

// Inspect accepts an inspector function that has same arguments as the Repository.GetRSSBySource
func (mmGetRSSBySource *mRepositoryMockGetRSSBySource) Inspect(f func(ctx context.Context, data models.DCData)) *mRepositoryMockGetRSSBySource {
	if mmGetRSSBySource.mock.inspectFuncGetRSSBySource != nil {
		mmGetRSSBySource.mock.t.Fatalf("Inspect function is already set for RepositoryMock.GetRSSBySource")
	}

	mmGetRSSBySource.mock.inspectFuncGetRSSBySource = f

	return mmGetRSSBySource
}

// Return sets up results that will be returned by Repository.GetRSSBySource
func (mmGetRSSBySource *mRepositoryMockGetRSSBySource) Return(r1 models.RSSNews, err error) *RepositoryMock {
	if mmGetRSSBySource.mock.funcGetRSSBySource != nil {
		mmGetRSSBySource.mock.t.Fatalf("RepositoryMock.GetRSSBySource mock is already set by Set")
	}

	if mmGetRSSBySource.defaultExpectation == nil {
		mmGetRSSBySource.defaultExpectation = &RepositoryMockGetRSSBySourceExpectation{mock: mmGetRSSBySource.mock}
	}
	mmGetRSSBySource.defaultExpectation.results = &RepositoryMockGetRSSBySourceResults{r1, err}
	return mmGetRSSBySource.mock
}

//Set uses given function f to mock the Repository.GetRSSBySource method
func (mmGetRSSBySource *mRepositoryMockGetRSSBySource) Set(f func(ctx context.Context, data models.DCData) (r1 models.RSSNews, err error)) *RepositoryMock {
	if mmGetRSSBySource.defaultExpectation != nil {
		mmGetRSSBySource.mock.t.Fatalf("Default expectation is already set for the Repository.GetRSSBySource method")
	}

	if len(mmGetRSSBySource.expectations) > 0 {
		mmGetRSSBySource.mock.t.Fatalf("Some expectations are already set for the Repository.GetRSSBySource method")
	}

	mmGetRSSBySource.mock.funcGetRSSBySource = f
	return mmGetRSSBySource.mock
}

// When sets expectation for the Repository.GetRSSBySource which will trigger the result defined by the following
// Then helper
func (mmGetRSSBySource *mRepositoryMockGetRSSBySource) When(ctx context.Context, data models.DCData) *RepositoryMockGetRSSBySourceExpectation {
	if mmGetRSSBySource.mock.funcGetRSSBySource != nil {
		mmGetRSSBySource.mock.t.Fatalf("RepositoryMock.GetRSSBySource mock is already set by Set")
	}

	expectation := &RepositoryMockGetRSSBySourceExpectation{
		mock:   mmGetRSSBySource.mock,
		params: &RepositoryMockGetRSSBySourceParams{ctx, data},
	}
	mmGetRSSBySource.expectations = append(mmGetRSSBySource.expectations, expectation)
	return expectation
}

// Then sets up Repository.GetRSSBySource return parameters for the expectation previously defined by the When method
func (e *RepositoryMockGetRSSBySourceExpectation) Then(r1 models.RSSNews, err error) *RepositoryMock {
	e.results = &RepositoryMockGetRSSBySourceResults{r1, err}
	return e.mock
}

// GetRSSBySource implements Repository
func (mmGetRSSBySource *RepositoryMock) GetRSSBySource(ctx context.Context, data models.DCData) (r1 models.RSSNews, err error) {
	mm_atomic.AddUint64(&mmGetRSSBySource.beforeGetRSSBySourceCounter, 1)
	defer mm_atomic.AddUint64(&mmGetRSSBySource.afterGetRSSBySourceCounter, 1)

	if mmGetRSSBySource.inspectFuncGetRSSBySource != nil {
		mmGetRSSBySource.inspectFuncGetRSSBySource(ctx, data)
	}

	mm_params := &RepositoryMockGetRSSBySourceParams{ctx, data}

	// Record call args
	mmGetRSSBySource.GetRSSBySourceMock.mutex.Lock()
	mmGetRSSBySource.GetRSSBySourceMock.callArgs = append(mmGetRSSBySource.GetRSSBySourceMock.callArgs, mm_params)
	mmGetRSSBySource.GetRSSBySourceMock.mutex.Unlock()

	for _, e := range mmGetRSSBySource.GetRSSBySourceMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.r1, e.results.err
		}
	}

	if mmGetRSSBySource.GetRSSBySourceMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetRSSBySource.GetRSSBySourceMock.defaultExpectation.Counter, 1)
		mm_want := mmGetRSSBySource.GetRSSBySourceMock.defaultExpectation.params
		mm_got := RepositoryMockGetRSSBySourceParams{ctx, data}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetRSSBySource.t.Errorf("RepositoryMock.GetRSSBySource got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetRSSBySource.GetRSSBySourceMock.defaultExpectation.results
		if mm_results == nil {
			mmGetRSSBySource.t.Fatal("No results are set for the RepositoryMock.GetRSSBySource")
		}
		return (*mm_results).r1, (*mm_results).err
	}
	if mmGetRSSBySource.funcGetRSSBySource != nil {
		return mmGetRSSBySource.funcGetRSSBySource(ctx, data)
	}
	mmGetRSSBySource.t.Fatalf("Unexpected call to RepositoryMock.GetRSSBySource. %v %v", ctx, data)
	return
}

// GetRSSBySourceAfterCounter returns a count of finished RepositoryMock.GetRSSBySource invocations
func (mmGetRSSBySource *RepositoryMock) GetRSSBySourceAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetRSSBySource.afterGetRSSBySourceCounter)
}

// GetRSSBySourceBeforeCounter returns a count of RepositoryMock.GetRSSBySource invocations
func (mmGetRSSBySource *RepositoryMock) GetRSSBySourceBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetRSSBySource.beforeGetRSSBySourceCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.GetRSSBySource.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetRSSBySource *mRepositoryMockGetRSSBySource) Calls() []*RepositoryMockGetRSSBySourceParams {
	mmGetRSSBySource.mutex.RLock()

	argCopy := make([]*RepositoryMockGetRSSBySourceParams, len(mmGetRSSBySource.callArgs))
	copy(argCopy, mmGetRSSBySource.callArgs)

	mmGetRSSBySource.mutex.RUnlock()

	return argCopy
}

// MinimockGetRSSBySourceDone returns true if the count of the GetRSSBySource invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockGetRSSBySourceDone() bool {
	for _, e := range m.GetRSSBySourceMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetRSSBySourceMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetRSSBySourceCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetRSSBySource != nil && mm_atomic.LoadUint64(&m.afterGetRSSBySourceCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetRSSBySourceInspect logs each unmet expectation
func (m *RepositoryMock) MinimockGetRSSBySourceInspect() {
	for _, e := range m.GetRSSBySourceMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.GetRSSBySource with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetRSSBySourceMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetRSSBySourceCounter) < 1 {
		if m.GetRSSBySourceMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryMock.GetRSSBySource")
		} else {
			m.t.Errorf("Expected call to RepositoryMock.GetRSSBySource with params: %#v", *m.GetRSSBySourceMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetRSSBySource != nil && mm_atomic.LoadUint64(&m.afterGetRSSBySourceCounter) < 1 {
		m.t.Error("Expected call to RepositoryMock.GetRSSBySource")
	}
}

type mRepositoryMockGetSrcsByChat struct {
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockGetSrcsByChatExpectation
	expectations       []*RepositoryMockGetSrcsByChatExpectation

	callArgs []*RepositoryMockGetSrcsByChatParams
	mutex    sync.RWMutex
}

// RepositoryMockGetSrcsByChatExpectation specifies expectation struct of the Repository.GetSrcsByChat
type RepositoryMockGetSrcsByChatExpectation struct {
	mock    *RepositoryMock
	params  *RepositoryMockGetSrcsByChatParams
	results *RepositoryMockGetSrcsByChatResults
	Counter uint64
}

// RepositoryMockGetSrcsByChatParams contains parameters of the Repository.GetSrcsByChat
type RepositoryMockGetSrcsByChatParams struct {
	ctx  context.Context
	user models.User
}

// RepositoryMockGetSrcsByChatResults contains results of the Repository.GetSrcsByChat
type RepositoryMockGetSrcsByChatResults struct {
	s1  models.Sources
	err error
}

// Expect sets up expected params for Repository.GetSrcsByChat
func (mmGetSrcsByChat *mRepositoryMockGetSrcsByChat) Expect(ctx context.Context, user models.User) *mRepositoryMockGetSrcsByChat {
	if mmGetSrcsByChat.mock.funcGetSrcsByChat != nil {
		mmGetSrcsByChat.mock.t.Fatalf("RepositoryMock.GetSrcsByChat mock is already set by Set")
	}

	if mmGetSrcsByChat.defaultExpectation == nil {
		mmGetSrcsByChat.defaultExpectation = &RepositoryMockGetSrcsByChatExpectation{}
	}

	mmGetSrcsByChat.defaultExpectation.params = &RepositoryMockGetSrcsByChatParams{ctx, user}
	for _, e := range mmGetSrcsByChat.expectations {
		if minimock.Equal(e.params, mmGetSrcsByChat.defaultExpectation.params) {
			mmGetSrcsByChat.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetSrcsByChat.defaultExpectation.params)
		}
	}

	return mmGetSrcsByChat
}

// Inspect accepts an inspector function that has same arguments as the Repository.GetSrcsByChat
func (mmGetSrcsByChat *mRepositoryMockGetSrcsByChat) Inspect(f func(ctx context.Context, user models.User)) *mRepositoryMockGetSrcsByChat {
	if mmGetSrcsByChat.mock.inspectFuncGetSrcsByChat != nil {
		mmGetSrcsByChat.mock.t.Fatalf("Inspect function is already set for RepositoryMock.GetSrcsByChat")
	}

	mmGetSrcsByChat.mock.inspectFuncGetSrcsByChat = f

	return mmGetSrcsByChat
}

// Return sets up results that will be returned by Repository.GetSrcsByChat
func (mmGetSrcsByChat *mRepositoryMockGetSrcsByChat) Return(s1 models.Sources, err error) *RepositoryMock {
	if mmGetSrcsByChat.mock.funcGetSrcsByChat != nil {
		mmGetSrcsByChat.mock.t.Fatalf("RepositoryMock.GetSrcsByChat mock is already set by Set")
	}

	if mmGetSrcsByChat.defaultExpectation == nil {
		mmGetSrcsByChat.defaultExpectation = &RepositoryMockGetSrcsByChatExpectation{mock: mmGetSrcsByChat.mock}
	}
	mmGetSrcsByChat.defaultExpectation.results = &RepositoryMockGetSrcsByChatResults{s1, err}
	return mmGetSrcsByChat.mock
}

//Set uses given function f to mock the Repository.GetSrcsByChat method
func (mmGetSrcsByChat *mRepositoryMockGetSrcsByChat) Set(f func(ctx context.Context, user models.User) (s1 models.Sources, err error)) *RepositoryMock {
	if mmGetSrcsByChat.defaultExpectation != nil {
		mmGetSrcsByChat.mock.t.Fatalf("Default expectation is already set for the Repository.GetSrcsByChat method")
	}

	if len(mmGetSrcsByChat.expectations) > 0 {
		mmGetSrcsByChat.mock.t.Fatalf("Some expectations are already set for the Repository.GetSrcsByChat method")
	}

	mmGetSrcsByChat.mock.funcGetSrcsByChat = f
	return mmGetSrcsByChat.mock
}

// When sets expectation for the Repository.GetSrcsByChat which will trigger the result defined by the following
// Then helper
func (mmGetSrcsByChat *mRepositoryMockGetSrcsByChat) When(ctx context.Context, user models.User) *RepositoryMockGetSrcsByChatExpectation {
	if mmGetSrcsByChat.mock.funcGetSrcsByChat != nil {
		mmGetSrcsByChat.mock.t.Fatalf("RepositoryMock.GetSrcsByChat mock is already set by Set")
	}

	expectation := &RepositoryMockGetSrcsByChatExpectation{
		mock:   mmGetSrcsByChat.mock,
		params: &RepositoryMockGetSrcsByChatParams{ctx, user},
	}
	mmGetSrcsByChat.expectations = append(mmGetSrcsByChat.expectations, expectation)
	return expectation
}

// Then sets up Repository.GetSrcsByChat return parameters for the expectation previously defined by the When method
func (e *RepositoryMockGetSrcsByChatExpectation) Then(s1 models.Sources, err error) *RepositoryMock {
	e.results = &RepositoryMockGetSrcsByChatResults{s1, err}
	return e.mock
}

// GetSrcsByChat implements Repository
func (mmGetSrcsByChat *RepositoryMock) GetSrcsByChat(ctx context.Context, user models.User) (s1 models.Sources, err error) {
	mm_atomic.AddUint64(&mmGetSrcsByChat.beforeGetSrcsByChatCounter, 1)
	defer mm_atomic.AddUint64(&mmGetSrcsByChat.afterGetSrcsByChatCounter, 1)

	if mmGetSrcsByChat.inspectFuncGetSrcsByChat != nil {
		mmGetSrcsByChat.inspectFuncGetSrcsByChat(ctx, user)
	}

	mm_params := &RepositoryMockGetSrcsByChatParams{ctx, user}

	// Record call args
	mmGetSrcsByChat.GetSrcsByChatMock.mutex.Lock()
	mmGetSrcsByChat.GetSrcsByChatMock.callArgs = append(mmGetSrcsByChat.GetSrcsByChatMock.callArgs, mm_params)
	mmGetSrcsByChat.GetSrcsByChatMock.mutex.Unlock()

	for _, e := range mmGetSrcsByChat.GetSrcsByChatMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s1, e.results.err
		}
	}

	if mmGetSrcsByChat.GetSrcsByChatMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetSrcsByChat.GetSrcsByChatMock.defaultExpectation.Counter, 1)
		mm_want := mmGetSrcsByChat.GetSrcsByChatMock.defaultExpectation.params
		mm_got := RepositoryMockGetSrcsByChatParams{ctx, user}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetSrcsByChat.t.Errorf("RepositoryMock.GetSrcsByChat got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetSrcsByChat.GetSrcsByChatMock.defaultExpectation.results
		if mm_results == nil {
			mmGetSrcsByChat.t.Fatal("No results are set for the RepositoryMock.GetSrcsByChat")
		}
		return (*mm_results).s1, (*mm_results).err
	}
	if mmGetSrcsByChat.funcGetSrcsByChat != nil {
		return mmGetSrcsByChat.funcGetSrcsByChat(ctx, user)
	}
	mmGetSrcsByChat.t.Fatalf("Unexpected call to RepositoryMock.GetSrcsByChat. %v %v", ctx, user)
	return
}

// GetSrcsByChatAfterCounter returns a count of finished RepositoryMock.GetSrcsByChat invocations
func (mmGetSrcsByChat *RepositoryMock) GetSrcsByChatAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetSrcsByChat.afterGetSrcsByChatCounter)
}

// GetSrcsByChatBeforeCounter returns a count of RepositoryMock.GetSrcsByChat invocations
func (mmGetSrcsByChat *RepositoryMock) GetSrcsByChatBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetSrcsByChat.beforeGetSrcsByChatCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.GetSrcsByChat.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetSrcsByChat *mRepositoryMockGetSrcsByChat) Calls() []*RepositoryMockGetSrcsByChatParams {
	mmGetSrcsByChat.mutex.RLock()

	argCopy := make([]*RepositoryMockGetSrcsByChatParams, len(mmGetSrcsByChat.callArgs))
	copy(argCopy, mmGetSrcsByChat.callArgs)

	mmGetSrcsByChat.mutex.RUnlock()

	return argCopy
}

// MinimockGetSrcsByChatDone returns true if the count of the GetSrcsByChat invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockGetSrcsByChatDone() bool {
	for _, e := range m.GetSrcsByChatMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetSrcsByChatMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetSrcsByChatCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetSrcsByChat != nil && mm_atomic.LoadUint64(&m.afterGetSrcsByChatCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetSrcsByChatInspect logs each unmet expectation
func (m *RepositoryMock) MinimockGetSrcsByChatInspect() {
	for _, e := range m.GetSrcsByChatMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.GetSrcsByChat with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetSrcsByChatMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetSrcsByChatCounter) < 1 {
		if m.GetSrcsByChatMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepositoryMock.GetSrcsByChat")
		} else {
			m.t.Errorf("Expected call to RepositoryMock.GetSrcsByChat with params: %#v", *m.GetSrcsByChatMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetSrcsByChat != nil && mm_atomic.LoadUint64(&m.afterGetSrcsByChatCounter) < 1 {
		m.t.Error("Expected call to RepositoryMock.GetSrcsByChat")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *RepositoryMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockCreateSourceInspect()

		m.MinimockCreateUserInspect()

		m.MinimockDeleteSourceInspect()

		m.MinimockGetRSSBySourceInspect()

		m.MinimockGetSrcsByChatInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *RepositoryMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *RepositoryMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCreateSourceDone() &&
		m.MinimockCreateUserDone() &&
		m.MinimockDeleteSourceDone() &&
		m.MinimockGetRSSBySourceDone() &&
		m.MinimockGetSrcsByChatDone()
}
